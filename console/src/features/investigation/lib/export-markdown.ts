import type {
  CandidateRow,
  CostInfo,
  Experiment,
  Finding,
  Hypothesis,
  NegativeControl,
  ValidationMetricsData,
} from "../types";

export interface ExportData {
  prompt: string;
  summary: string;
  hypotheses: Hypothesis[];
  experiments: Experiment[];
  findings: Finding[];
  candidates: CandidateRow[];
  negativeControls: NegativeControl[];
  cost: CostInfo | null;
  validationMetrics?: ValidationMetricsData | null;
}

export function generateMarkdown(data: ExportData): string {
  const sections: string[] = [];

  sections.push("# Investigation Report\n");
  sections.push(`_Generated by Ehrlich - AI Scientific Discovery Engine_\n`);

  // 1. Research Question
  if (data.prompt) {
    sections.push("## Research Question\n");
    sections.push(`> ${data.prompt}\n`);
  }

  // 2. Executive Summary
  if (data.summary) {
    sections.push("## Executive Summary\n");
    sections.push(`${data.summary}\n`);
  }

  // 3. Hypotheses & Outcomes
  if (data.hypotheses.length > 0) {
    sections.push(`## Hypotheses & Outcomes (${data.hypotheses.length})\n`);
    sections.push("| Status | Confidence | Statement |");
    sections.push("|--------|------------|-----------|");
    for (const h of data.hypotheses) {
      const conf = h.confidence > 0 ? `${(h.confidence * 100).toFixed(0)}%` : "-";
      sections.push(`| ${h.status} | ${conf} | ${h.statement} |`);
    }
    sections.push("");
  }

  // 4. Methodology
  if (data.experiments.length > 0) {
    sections.push(`## Methodology (${data.experiments.length} experiments)\n`);
    for (const h of data.hypotheses) {
      const exps = data.experiments.filter((e) => e.hypothesis_id === h.id);
      if (exps.length === 0) continue;
      sections.push(`### Hypothesis: ${h.statement.slice(0, 100)}\n`);
      sections.push(`**Status:** ${h.status} | **Confidence:** ${h.confidence > 0 ? `${(h.confidence * 100).toFixed(0)}%` : "-"}\n`);
      for (const exp of exps) {
        sections.push(`- ${exp.description}`);
        if (exp.tool_count != null) {
          sections.push(`  - ${exp.tool_count} tool calls, ${exp.finding_count ?? 0} findings`);
        }
      }
      sections.push("");
    }
  }

  // 5. Key Findings
  if (data.findings.length > 0) {
    sections.push(`## Key Findings (${data.findings.length})\n`);
    const byType = { supporting: [] as Finding[], contradicting: [] as Finding[], neutral: [] as Finding[] };
    for (const f of data.findings) {
      const bucket = byType[f.evidence_type as keyof typeof byType] ?? byType.neutral;
      bucket.push(f);
    }
    for (const [type, items] of Object.entries(byType)) {
      if (items.length === 0) continue;
      sections.push(`### ${type.charAt(0).toUpperCase() + type.slice(1)} (${items.length})\n`);
      for (const f of items) {
        const source = f.source_type && f.source_id ? ` [${f.source_type}: ${f.source_id}]` : "";
        sections.push(`- **${f.title}**${source}`);
        sections.push(`  ${f.detail}`);
      }
      sections.push("");
    }
  }

  // 6. Candidates
  if (data.candidates.length > 0) {
    sections.push(`## Candidates (${data.candidates.length})\n`);

    // Collect all score keys and attribute keys across candidates
    const scoreKeys = new Set<string>();
    const attrKeys = new Set<string>();
    for (const c of data.candidates) {
      for (const k of Object.keys(c.scores)) scoreKeys.add(k);
      for (const k of Object.keys(c.attributes)) attrKeys.add(k);
    }

    const scoreHeaders = [...scoreKeys];
    const attrHeaders = [...attrKeys];
    const hasExtra = scoreHeaders.length > 0 || attrHeaders.length > 0;

    if (hasExtra) {
      const headers = ["Rank", "Name", "Identifier", ...scoreHeaders.map(h => h.replace(/_/g, " ")), ...attrHeaders.map(h => h.replace(/_/g, " "))];
      sections.push(`| ${headers.join(" | ")} |`);
      sections.push(`|${headers.map(() => "------").join("|")}|`);
      for (const c of data.candidates) {
        const scores = scoreHeaders.map((k) => c.scores[k] != null ? c.scores[k].toFixed(2) : "-");
        const attrs = attrHeaders.map((k) => c.attributes[k] ?? "-");
        sections.push(`| ${c.rank} | ${c.name || "-"} | \`${c.identifier}\` | ${[...scores, ...attrs].join(" | ")} |`);
      }
    } else {
      sections.push("| Rank | Name | Identifier | Notes |");
      sections.push("|------|------|------------|-------|");
      for (const c of data.candidates) {
        sections.push(`| ${c.rank} | ${c.name || "-"} | \`${c.identifier}\` | ${c.notes || "-"} |`);
      }
    }
    sections.push("");
  }

  // 7. Model Validation
  if (data.negativeControls.length > 0) {
    const correct = data.negativeControls.filter((nc) => nc.correctly_classified).length;
    sections.push(`## Model Validation (${correct}/${data.negativeControls.length} correct)\n`);
    sections.push("| Compound | Identifier | Score | Classified |");
    sections.push("|----------|------------|-------|------------|");
    for (const nc of data.negativeControls) {
      sections.push(`| ${nc.name || "-"} | \`${nc.identifier}\` | ${nc.score.toFixed(3)} | ${nc.correctly_classified ? "Pass" : "Fail"} |`);
    }
    sections.push("");
    if (data.validationMetrics && data.validationMetrics.z_prime != null) {
      const vm = data.validationMetrics;
      const zp = vm.z_prime as number;
      sections.push(`**Z'-factor:** ${zp.toFixed(3)} (${vm.z_prime_quality})\n`);
      sections.push(`- Positive controls: mean=${vm.positive_mean.toFixed(3)}, n=${vm.positive_control_count}`);
      sections.push(`- Negative controls: mean=${vm.negative_mean.toFixed(3)}, n=${vm.negative_control_count}`);
      sections.push("");
    }
  }

  // 8. Cost & Performance
  if (data.cost) {
    sections.push("## Cost & Performance\n");
    sections.push(`- **Input Tokens:** ${data.cost.inputTokens.toLocaleString()}`);
    sections.push(`- **Output Tokens:** ${data.cost.outputTokens.toLocaleString()}`);
    sections.push(`- **Tool Calls:** ${data.cost.toolCalls}`);
    sections.push(`- **Total Cost:** $${data.cost.totalCost.toFixed(4)}`);
    if (data.cost.byRole) {
      sections.push("\n| Role | Model | Input | Output | Calls | Cost |");
      sections.push("|------|-------|-------|--------|-------|------|");
      for (const [role, mc] of Object.entries(data.cost.byRole)) {
        sections.push(`| ${role} | ${mc.model_display} | ${mc.input_tokens.toLocaleString()} | ${mc.output_tokens.toLocaleString()} | ${mc.calls} | $${mc.cost_usd.toFixed(4)} |`);
      }
    }
    sections.push("");
  }

  return sections.join("\n");
}

export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: "text/markdown;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
