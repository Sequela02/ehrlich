import type {
  CandidateRow,
  CostInfo,
  Experiment,
  Finding,
  Hypothesis,
  NegativeControl,
} from "../types";

export interface ExportData {
  prompt: string;
  summary: string;
  hypotheses: Hypothesis[];
  experiments: Experiment[];
  findings: Finding[];
  candidates: CandidateRow[];
  negativeControls: NegativeControl[];
  cost: CostInfo | null;
}

export function generateMarkdown(data: ExportData): string {
  const sections: string[] = [];

  sections.push("# Investigation Report\n");
  sections.push(`_Generated by Ehrlich - AI Molecular Discovery Engine_\n`);

  // 1. Research Question
  if (data.prompt) {
    sections.push("## Research Question\n");
    sections.push(`> ${data.prompt}\n`);
  }

  // 2. Executive Summary
  if (data.summary) {
    sections.push("## Executive Summary\n");
    sections.push(`${data.summary}\n`);
  }

  // 3. Hypotheses & Outcomes
  if (data.hypotheses.length > 0) {
    sections.push(`## Hypotheses & Outcomes (${data.hypotheses.length})\n`);
    sections.push("| Status | Confidence | Statement |");
    sections.push("|--------|------------|-----------|");
    for (const h of data.hypotheses) {
      const conf = h.confidence > 0 ? `${(h.confidence * 100).toFixed(0)}%` : "-";
      sections.push(`| ${h.status} | ${conf} | ${h.statement} |`);
    }
    sections.push("");
  }

  // 4. Methodology
  if (data.experiments.length > 0) {
    sections.push(`## Methodology (${data.experiments.length} experiments)\n`);
    for (const h of data.hypotheses) {
      const exps = data.experiments.filter((e) => e.hypothesis_id === h.id);
      if (exps.length === 0) continue;
      sections.push(`### Hypothesis: ${h.statement.slice(0, 100)}\n`);
      sections.push(`**Status:** ${h.status} | **Confidence:** ${h.confidence > 0 ? `${(h.confidence * 100).toFixed(0)}%` : "-"}\n`);
      for (const exp of exps) {
        sections.push(`- ${exp.description}`);
        if (exp.tool_count != null) {
          sections.push(`  - ${exp.tool_count} tool calls, ${exp.finding_count ?? 0} findings`);
        }
      }
      sections.push("");
    }
  }

  // 5. Key Findings
  if (data.findings.length > 0) {
    sections.push(`## Key Findings (${data.findings.length})\n`);
    const byType = { supporting: [] as Finding[], contradicting: [] as Finding[], neutral: [] as Finding[] };
    for (const f of data.findings) {
      const bucket = byType[f.evidence_type as keyof typeof byType] ?? byType.neutral;
      bucket.push(f);
    }
    for (const [type, items] of Object.entries(byType)) {
      if (items.length === 0) continue;
      sections.push(`### ${type.charAt(0).toUpperCase() + type.slice(1)} (${items.length})\n`);
      for (const f of items) {
        const source = f.source_type && f.source_id ? ` [${f.source_type}: ${f.source_id}]` : "";
        sections.push(`- **${f.title}**${source}`);
        sections.push(`  ${f.detail}`);
      }
      sections.push("");
    }
  }

  // 6. Candidate Molecules
  if (data.candidates.length > 0) {
    sections.push(`## Candidate Molecules (${data.candidates.length})\n`);
    const hasScores = data.candidates.some(
      (c) => (c.prediction_score ?? 0) > 0 || (c.docking_score ?? 0) !== 0,
    );
    if (hasScores) {
      sections.push("| Rank | Name | SMILES | Prediction | Docking | ADMET | Risk |");
      sections.push("|------|------|--------|------------|---------|-------|------|");
      for (const c of data.candidates) {
        const pred = c.prediction_score != null ? c.prediction_score.toFixed(2) : "-";
        const dock = c.docking_score != null ? c.docking_score.toFixed(1) : "-";
        const admet = c.admet_score != null ? c.admet_score.toFixed(2) : "-";
        const risk = c.resistance_risk ?? "-";
        sections.push(`| ${c.rank} | ${c.name || "-"} | \`${c.smiles}\` | ${pred} | ${dock} | ${admet} | ${risk} |`);
      }
    } else {
      sections.push("| Rank | Name | SMILES | Notes |");
      sections.push("|------|------|--------|-------|");
      for (const c of data.candidates) {
        sections.push(`| ${c.rank} | ${c.name || "-"} | \`${c.smiles}\` | ${c.notes || "-"} |`);
      }
    }
    sections.push("");
  }

  // 7. Model Validation
  if (data.negativeControls.length > 0) {
    const correct = data.negativeControls.filter((nc) => nc.correctly_classified).length;
    sections.push(`## Model Validation (${correct}/${data.negativeControls.length} correct)\n`);
    sections.push("| Compound | SMILES | Score | Classified |");
    sections.push("|----------|--------|-------|------------|");
    for (const nc of data.negativeControls) {
      sections.push(`| ${nc.name || "-"} | \`${nc.smiles}\` | ${nc.prediction_score.toFixed(3)} | ${nc.correctly_classified ? "Pass" : "Fail"} |`);
    }
    sections.push("");
  }

  // 8. Cost & Performance
  if (data.cost) {
    sections.push("## Cost & Performance\n");
    sections.push(`- **Input Tokens:** ${data.cost.inputTokens.toLocaleString()}`);
    sections.push(`- **Output Tokens:** ${data.cost.outputTokens.toLocaleString()}`);
    sections.push(`- **Tool Calls:** ${data.cost.toolCalls}`);
    sections.push(`- **Total Cost:** $${data.cost.totalCost.toFixed(4)}`);
    if (data.cost.byModel) {
      sections.push("\n| Model | Input | Output | Calls | Cost |");
      sections.push("|-------|-------|--------|-------|------|");
      for (const [model, mc] of Object.entries(data.cost.byModel)) {
        sections.push(`| ${model} | ${mc.input_tokens.toLocaleString()} | ${mc.output_tokens.toLocaleString()} | ${mc.calls} | $${mc.cost_usd.toFixed(4)} |`);
      }
    }
    sections.push("");
  }

  return sections.join("\n");
}

export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: "text/markdown;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
